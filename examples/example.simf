mod witness {
    const challenge: Scalar =
        76079921600172625841227013193223526848675225718990118529172758833198041956525;
    const x_r: Scalar =
        65250272532514928625212504451703505485132270400975660596845266592891500596580;
    const r1_r: Scalar =
        40625900171226647199004953476471869210723000065655569997098986400656057793321;
    const r2_r: Scalar =
        7177867232998069979913028596193836896268967457459286456881769818603861550107;

    const A: Gej = (
        (
            110425132228045755865368506016428806583709496314906484912218358624957255142377,
            100663101999611873373514841124501644381176635717649791716703058510469405630460
        ),
        1
    );
    const A_r: Gej = (
        (
            73531381981792542246172867102055406694930592900449254828142235261515238593633,
            69124271499702732403513555678815458762801413341558690982198328443623580946053
        ),
        1
    );

    const B: Gej = (
        (
            59948879718777467256620177349254225418140997916012847484865415347635883695673,
            38829494743395463042827203657809518582451355194269209079046960050171713839099
        ),
        1
    );
    const B_r: Gej = (
        (
            73654170524580798922940556795497459949942890146209997275430973313388306686004,
            35109736567033858709620261124557037275879859610881348219271799707749825202476
        ),
        1
    );
}

mod param {
    const G: Gej = (
        (
            55066263022277343669578718895168534326250603453777594175500187360389116729240,
            32670510020758816978083085130507043184471273380659243275938904335757337482424
        ),
        1
    );
    const H: Gej = (
        (
            11236042910693443396562549142412268574484138722337004402789503812037366240707,
            47437054805956805922366037454516728935198867368076700184530077286185596903476
        ),
        1
    );
}
fn compute_challenge(instance: (Gej, Gej), commitments: (Gej, Gej)) -> Scalar {
    let (A, B): (Gej, Gej) = instance;
    let (A_r, B_r): (Gej, Gej) = commitments;
    let ctx: Ctx8 = jet::sha_256_ctx_8_init();
    let (A_x, A_y): (u256, u256) = unwrap(jet::gej_normalize(A));
    let (A_r_x, A_r_y): (u256, u256) = unwrap(jet::gej_normalize(A_r));
    let ctx: Ctx8 = jet::sha_256_ctx_8_add_32(ctx, A_x);
    let ctx: Ctx8 = jet::sha_256_ctx_8_add_32(ctx, A_y);
    let ctx: Ctx8 = jet::sha_256_ctx_8_add_32(ctx, A_r_x);
    let ctx: Ctx8 = jet::sha_256_ctx_8_add_32(ctx, A_r_y);

    let (B_x, B_y): (u256, u256) = unwrap(jet::gej_normalize(B));
    let (B_r_x, B_r_y): (u256, u256) = unwrap(jet::gej_normalize(B_r));
    let ctx: Ctx8 = jet::sha_256_ctx_8_add_32(ctx, B_x);
    let ctx: Ctx8 = jet::sha_256_ctx_8_add_32(ctx, B_y);
    let ctx: Ctx8 = jet::sha_256_ctx_8_add_32(ctx, B_r_x);
    let ctx: Ctx8 = jet::sha_256_ctx_8_add_32(ctx, B_r_y);

    jet::scalar_normalize(jet::sha_256_ctx_8_finalize(ctx))
}

fn verify_proof_batchable(
    public_vars: (Gej, Gej),
    response: (Scalar, Scalar, Scalar),
    instance: (Gej, Gej),
    commitments: (Gej, Gej)
) {
    let (G, H): (Gej, Gej) = public_vars;
    let (x_r, r1_r, r2_r): (Scalar, Scalar, Scalar) = response;
    let (A, B): (Gej, Gej) = instance;
    let (A_r, B_r): (Gej, Gej) = commitments;

    let challenge: Scalar = compute_challenge(instance, commitments);
    let A_lhs: Gej = jet::scale(x_r, G);
    let A_lhs: Gej = jet::gej_add(jet::scale(r1_r, H), A_lhs);

    let A_rhs: Gej = jet::scale(challenge, A);
    let A_rhs: Gej = jet::gej_add(A_r, A_rhs);

    assert!(jet::gej_equiv(A_lhs, A_rhs));

    let B_lhs: Gej = jet::scale(x_r, G);
    let B_lhs: Gej = jet::gej_add(jet::scale(r2_r, H), B_lhs);

    let B_rhs: Gej = jet::scale(challenge, B);
    let B_rhs: Gej = jet::gej_add(B_r, B_rhs);

    assert!(jet::gej_equiv(B_lhs, B_rhs));
}
fn verify_proof_compact(
    public_vars: (Gej, Gej),
    response: (Scalar, Scalar, Scalar),
    instance: (Gej, Gej),
    challenge: Scalar
) {
    let (G, H): (Gej, Gej) = public_vars;
    let (x_r, r1_r, r2_r): (Scalar, Scalar, Scalar) = response;
    let (A, B): (Gej, Gej) = instance;

    let A_lhs: Gej = jet::scale(x_r, G);
    let A_lhs: Gej = jet::gej_add(jet::scale(r1_r, H), A_lhs);

    let A_rhs: Gej = jet::scale(challenge, A);
    let A_rhs: Gej = jet::gej_negate(A_rhs);

    let A_r: Gej = jet::gej_add(A_lhs, A_rhs);
    let B_lhs: Gej = jet::scale(x_r, G);
    let B_lhs: Gej = jet::gej_add(jet::scale(r2_r, H), B_lhs);

    let B_rhs: Gej = jet::scale(challenge, B);
    let B_rhs: Gej = jet::gej_negate(B_rhs);

    let B_r: Gej = jet::gej_add(B_lhs, B_rhs);
    let computed_challenge: Scalar = compute_challenge(instance, (A_r, B_r));
    assert!(jet::eq_256(challenge, computed_challenge));
}
fn main() {
    let public: (Gej, Gej) = (param::G, param::H);
    let response: (Scalar, Scalar, Scalar) = (witness::x_r, witness::r1_r, witness::r2_r);
    let instance: (Gej, Gej) = (witness::A, witness::B);
    let commitments: (Gej, Gej) = (witness::A_r, witness::B_r);
    verify_proof_batchable(public, response, instance, commitments);
    //verify_proof_compact(public, response, instance, witness::challenge);
}
